{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\QDelugia\\E$"}
{"rule":"THE_SUPERLATIVE","sentence":"^\\QAssignment I: All-Pairs Shortest Path Problem Miguel Ribeiro Pereira Tarso Boudet Caldas November 2022\\E$"}
{"rule":"THE_SUPERLATIVE","sentence":"^\\QWe have implemented Fox's algorithm to solve the All-pairs Shortest Path Problem, using the min-plus matrix multiplication applied to the matrix representation of a directed graph.\\E$"}
{"rule":"WORD_CONTAINS_UNDERSCORE","sentence":"^\\QIt is for this reason that we've substituted the MPI_Send() and MPI_Recv() commands with MPI_Sendrecv_replace().\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\Qfontsize=, linenos=true c\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\QDelugia STIXtwoMath-regular.otf\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\Qfontsize=, linenos=true c c fontsize=\\E$"}
{"rule":"ENGLISH_WORD_REPEAT_RULE","sentence":"^\\Qfontsize=, linenos=true c c fontsize=\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\Q#1#2#3 link HTML 800006 cite HTML 2E7E2A file HTML 131877 url HTML 8A0087 menu HTML 727500 run HTML 137776 #1#2 link !60!white cite !60!white file !60!white url !60!white menu !60!white run !60!white\\E$"}
{"rule":"THE_SUPERLATIVE","sentence":"^\\QWe have implemented Fox's algorithm to solve the all-pairs shortest path problem, using the min-plus matrix multiplication applied to the matrix representation of a directed graph.\\E$"}
{"rule":"THE_SUPERLATIVE","sentence":"^\\QWe have implemented Fox's algorithm to solve the All-Pairs Shortest Path Problem, using the min-plus matrix multiplication applied to the matrix representation of a directed graph.\\E$"}
{"rule":"PASSIVE_VOICE","sentence":"^\\QCommunication for the parallel solution was based on the MPI implementation.\\E$"}
{"rule":"AVAILABLE","sentence":"^\\QThis algorithm tries to divide the matrix multiplication of the original \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q matrices into matrix multiplications of smaller matrices that are calculated in each available processor.\\E$"}
{"rule":"PASSIVE_VOICE","sentence":"^\\QThe whole idea for the algorithm can be found in \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, but the main points are: The original \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q matrix is divided into \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q sub-matrices of dimension \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q.\\E$"}
{"rule":"PASSIVE_VOICE","sentence":"^\\QFor \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q iterations, we'll apply the following steps: we choose a matrix \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q from each row of processes (it can be any matrix \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q from any process of that row, but usually it is chosen from the processor in the diagonal of the original matrix), and broadcast it to the other processes in the same row; on each process, the received matrix \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q is multiplied (min-plus multiplication) by the matrix \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q currently in that process; the submatrix \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q from each process is sent to the process above it.\\E$"}
{"rule":"PASSIVE_VOICE","sentence":"^\\QThe original \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q matrix is divided into \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q sub-matrices of dimension \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q.\\E$"}
{"rule":"PASSIVE_VOICE","sentence":"^\\QThere is an important thing we can avail from the idea of Fox's algorithm, regarding the communicators: after dividing the original matrix into the \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q sub-matrices, each process only needs to communicate with processes in the same column or the same row as itself (communication with the row is needed for broadcasting the \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q sub-matrix from each process, and with the column to send the local \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q ones to the process above and receive it from the process below).\\E$"}
{"rule":"WORD_CONTAINS_UNDERSCORE","sentence":"^\\QTo simplify its creation and usage, we defined a new data structure, GRID_INFO_TYPE, that stores the important information for the grid communication (number of processes, rank and coordinates of each process in the grid, row and column communicators).\\E$"}
{"rule":"WORD_CONTAINS_UNDERSCORE","sentence":"^\\QTo simplify its creation and usage, we defined a new data structure, GRID_INFO_TYPE, that stores the important information for the grid communication (number of processes; rank and coordinates of each process in the grid; row and column communicators).\\E$"}
{"rule":"WORD_CONTAINS_UNDERSCORE","sentence":"^\\QWe've also used an auxiliary function, Setup_grid(), to initialize the Cartesian grid topology.\\E$"}
{"rule":"PASSIVE_VOICE","sentence":"^\\QBoth the data structure and the function were based on the ones presented in \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q.\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\QIf the matrix is in a contiguous memory position, we can use MPI_Bcast() as an easy way to disperse the \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q sub-matrices in a row, and MPI_Sendrecv_replace() to exchange \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q sub-matrices in a column.\\E$"}
{"rule":"FORM","sentence":"^\\QIn order to understand why this is needed, we'll explain the example presented in \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q: if we want to use this implementation to a \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q matrix divided by 4 processors (each one will have a \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q sub-matrix), then the values from this matrix that form the sub-matrix of processor 0 will be the entries \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q for \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q and \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q.\\E$"}
{"rule":"AVAILABLE","sentence":"^\\QThis algorithm tries to divide the multiplication of the original \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q matrices into multiplications of smaller matrices that are calculated in each processor available.\\E$"}
{"rule":"WORD_CONTAINS_UNDERSCORE","sentence":"^\\QTherefore, we would like to place the values regarding each processor together in the storage of the original matrix, since only in this case we can correctly apply the MPI_Scatter() function.\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\QTo solve the first problem, we used this auxiliary function initMat():\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\QAfter that, we created a new array of size \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, counter[n_procs], where counter[k] stores the number of values that belong to processor k's sub-matrix that have already been read with scanf().\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qrank_dest evaluates to which processor the entry \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q belongs to.\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\QThe function rank_dest evaluates which processor the entry \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q belongs to.\\E$"}
{"rule":"WORD_CONTAINS_UNDERSCORE","sentence":"^\\QThat is the index that appears in total_matrix[] when we call for scanf().\\E$"}
{"rule":"NOTICE","sentence":"^\\QIt's important to notice that the input matrices also have 0 entries for two different cases of connections: for the diagonal, which makes sense (the smallest distance from point \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q to point \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q is 0), and when there is not a direct path between two different points.\\E$"}
{"rule":"NOTICE","sentence":"^\\QIt's important to notice that the input matrices also have 0 entries for two different cases of connections: for the diagonal, as the smallest distance from point \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q to point \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q is 0, and when there is not a direct path between two different points.\\E$"}
{"rule":"WORD_CONTAINS_UNDERSCORE","sentence":"^\\QAfter reading the matrix, the usage of MPI_Scatter() to disperse it into each processor's sub-matrix is clear (notice that we scatter using the cartesian grid communicator instead of MPI_COMM_WORLD, since the rank of a certain processor might be different in each of these two communicators).\\E$"}
{"rule":"WORD_CONTAINS_UNDERSCORE","sentence":"^\\QAfter reading the matrix, the usage of MPI_Scatter() to disperse it into each processor's sub-matrix is clear (notice that we scatter using the Cartesian grid communicator instead of MPI_COMM_WORLD, since the rank of a certain processor might be different in each of these two communicators).\\E$"}
{"rule":"WORD_CONTAINS_UNDERSCORE","sentence":"^\\QAll we have to do is apply the Fox's algorithm one time, and that will give us the new matrix (after the first step, it will be \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q), but stored in the local_C sub-matrices, since these are the ones that are storing the lowest values from each matrix multiplication.\\E$"}
{"rule":"WORD_CONTAINS_UNDERSCORE","sentence":"^\\QWith Fox's algorithm used the amount of times needed, we call MPI_Gather() exactly to gather all the local \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q sub-matrices back into the memory of the original matrix (total_matrix), so we can do the final printing of our answer (the only care we need to have while printing is to map back the memory position in which we stored each entry of the matrix in the uni-dimensional array, into the actual position in the original 2-dimensional matrix).\\E$"}
{"rule":"WORD_CONTAINS_UNDERSCORE","sentence":"^\\QAbout our specific implementation, there were some other auxiliary functions that we haven't mentioned yet: array_set_to_zero() was used to reset the values of the counter array before we started counting the number of elements we have already scanned from each processor.\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qcopy_matrix() was used to copy the local \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q sub-matrices into the local \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q and \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q's after each call of the fox() function.\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qmatrix_multiplication() is the implementation of the min-plus matrix multiplication, where the minimum values of the multiplication of the \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q and \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q matrices are stored in the local \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q's.\\E$"}
{"rule":"PASSIVE_VOICE","sentence":"^\\Qmatrix_multiplication() is the implementation of the min-plus matrix multiplication, where the minimum values of the multiplication of the \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q and \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q matrices are stored in the local \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q's.\\E$"}
{"rule":"WORD_CONTAINS_UNDERSCORE","sentence":"^\\QThe execution time was the time measured after we scan the input matrix for the example in question, up to the moment before we print the solution (that is, it includes the time for the usage of the MPI_Scatter and MPI_Gather functions to disperse and aggregate the \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q matrix, and the while loop that implements the matrix iteration through Fox's algorithm).\\E$"}
{"rule":"DASH_RULE","sentence":"^\\QNumber of Processes input6 input300 input600 input900 input1200 1 1.5e-5 0.56 4.85 16.50 42.00 4 3.1e-5 0.15 1.27 4.29 1.56 9 8.1e-4 0.11 0.80 2.28 5.68 16 — 1 4 9 16 input6 1.5E-05 3.1E-05 8.10E-04 — input300 0.559 0.151 0.105 0.083 input600 4.85 1.27 0.80 0.52 input900 16.50 4.29 2.28 1.56 input1200 42.00 11.43 5.68 3.52 1 4 9 16 input6 1.5E-05 3.1E-05 8.10E-04 — input300 0.559 0.151 0.105 0.083 input600 4.85 1.27 0.80 0.52 input900 16.50 4.29 2.28 1.56 input1200 42.00 11.43 5.68 3.52 Execution time values.\\E$"}
{"rule":"DASH_RULE","sentence":"^\\QNumber of Processes input6 input300 input600 input900 input1200 1 1.5e-5 0.56 4.85 16.50 42.00 4 3.1e-5 0.15 1.27 4.29 1.56 9 8.1e-4 0.11 0.80 2.28 5.68 16 — 0.08 0.52 1.56 3.52 1 4 9 16 1 4 9 16 input6 1.5E-05 3.1E-05 8.10E-04 — input300 0.559 0.151 0.105 0.083 input600 4.85 1.27 0.80 0.52 input900 16.50 4.29 2.28 1.56 input1200 42.00 11.43 5.68 3.52 Execution time values.\\E$"}
{"rule":"THE_WORSE_OF","sentence":"^\\QAs previously said, this isn't the expected behavior, but it might happen due to the fact that this is a very small case (small \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q), and therefore we do not gain a significant speedup in execution by parallelizing the problem, and are actually slowing down the execution with the communication that happens by calling the MPI functions (like the scatter of the original matrix or the broadcast of local \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q sub-matrices).\\E$"}
{"rule":"PASSIVE_VOICE","sentence":"^\\QHowever, for a big enough input case, as we can see for input300 and the rest of the given examples, we do notice a significant reduction in execution time by increasing the number of processors, which corroborates the problem can in fact be parallelized.\\E$"}
{"rule":"WORD_CONTAINS_UNDERSCORE","sentence":"^\\QThe fox() function that was implemented in \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q showed a problem in certain cases of its usage: after each step iteration of the for loop, MPI_Send() and MPI_Recv() were used to send the local \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q matrix to the process above, and receive the one from the process below.\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\QThe fox() function that was implemented in \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q showed a problem in certain cases of its usage: after each step iteration of the for loop, MPI_Send() and MPI_Recv() were used to send the local \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q matrix to the process above, and receive the one from the process below.\\E$"}
{"rule":"WORD_CONTAINS_UNDERSCORE","sentence":"^\\QThat has to do with the fact that MPI_Send() works differently when we have small or large messages to send.\\E$"}
{"rule":"PREPOSITION_VERB","sentence":"^\\QHowever, Send() works as a synchronous send for large messages, and that's why, for the large matrices, we will have all the processors waiting for a synchronous send, but no one will skip to the next instruction that is the receive part, and therefore there is no communication and the program is stuck.\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\QIt is for this reason that we've substituted the MPI_Send() and MPI_Recv() commands with MPI_Sendrecv_replace().\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\QExecution Time () (lr)2-6 Number of Processes input6 input300 input600 input900 input1200 1 1.5e-5 0.56 4.85 16.50 42.00 4 3.1e-5 0.15 1.27 4.29 1.56 9 8.1e-4 0.11 0.80 2.28 5.68 16 — 0.08 0.52 1.56 3.52 Execution time values in seconds for each input file with different numbers of processes.\\E$"}
{"rule":"DASH_RULE","sentence":"^\\QExecution Time () (lr)2-6 Number of Processes input6 input300 input600 input900 input1200 1 1.5e-5 0.56 4.85 16.50 42.00 4 3.1e-5 0.15 1.27 4.29 1.56 9 8.1e-4 0.11 0.80 2.28 5.68 16 — 0.08 0.52 1.56 3.52 Execution time values in seconds for each input file with different numbers of processes.\\E$"}
